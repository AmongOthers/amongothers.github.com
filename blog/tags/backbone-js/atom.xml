<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: backbone.js | AmongOthers' Blog]]></title>
  <link href="http://AmongOthers.github.com/blog/tags/backbone-js/atom.xml" rel="self"/>
  <link href="http://AmongOthers.github.com/"/>
  <updated>2013-01-31T18:22:59+08:00</updated>
  <id>http://AmongOthers.github.com/</id>
  <author>
    <name><![CDATA[AmongOthers]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MV*与Backbone]]></title>
    <link href="http://AmongOthers.github.com/blog/2013/01/30/MVxx-and-Backbone/"/>
    <updated>2013-01-30T21:11:00+08:00</updated>
    <id>http://AmongOthers.github.com/blog/2013/01/30/MVxx-and-Backbone</id>
    <content type="html"><![CDATA[<h2>几种MV*框架的含义</h2>

<p>关键的区别就是，View是依赖于绑定还是直接操作？如果是绑定，那么绑定在谁身上。</p>

<h3>Classic MVC</h3>

<pre><code>View &lt;--- Controller ---&gt; Model
|___________________________^
</code></pre>

<h3>MVP</h3>

<p>Presenter并不直接依赖于View，而是依赖于ViewInterface的抽象，并具有直接操作View的能力。而在Supervising Controller方式的MVP中，View的渲染主要还是通过绑定在Model上，Presenter在比较复杂的情况下才出手；而Passive View方式的MVP中，View是无知的，Presenter控制View的渲染的细节。</p>

<h4>Supervising Controller</h4>

<pre><code>View as ViewInterface &lt;--- Presenter ---&gt; Model
 |__________________________________________^
</code></pre>

<h4>Passive View</h4>

<pre><code>View as ViewInterface &lt;--- Presenter ---&gt; Model
</code></pre>

<h3>MVVM(Presentation Model)</h3>

<p>源自微软的WPF的一套模式，View绑定在ViewModel的属性上（面向对象的方式：增加一个间接层来解决问题），ViewModel不会直接操作View。</p>

<pre><code>View ---&gt; ViewModel ---&gt; Model
</code></pre>

<h2>例子</h2>

<p>URL: "index.html#"</p>

<p><img src="/images/routing-in-backbone/default.png" alt="" /></p>

<p>URL: "index.html#/active"</p>

<p><img src="/images/routing-in-backbone/active.png" alt="" /></p>

<p>一开始我认为Route的本质是：</p>

<blockquote><blockquote><p>对URL附加的hash tags(#)的响应而进入应用的相应状态的过程</p></blockquote></blockquote>

<p>但是就像 "http://example.com/#/posts/12" 表示访问id为12的文章， URL代表着资源，因此更自然的观点是：</p>

<blockquote><blockquote><p>应用程序的不同的数据集合通过URL hash tag进行标识以便索引</p></blockquote></blockquote>

<p>虽然后者显得更加自然，但是这个是Classic MVC的方式，将View绑定到新的Model上，用的比较少。MVP则通过Presenter控制某个项目是否hidden来实现（TodoMVC Backbone），而MVVM中，View绑定在动态改变的ViewModel的属性上，本例中可以是Visible Items。</p>

<p>BackBone.js没有天然的数据绑定。它倾向于Passive View方式的MVP。不过它的设计意图是对各种模式开放，而不假定:</p>

<p><a href="http://addyosmani.com/blog/understanding-mvc-and-mvp-for-javascript-and-backbone-developers/">Understanding MVC And MVP (For JavaScript And Backbone Developers) by Addy Osmani</a></p>
]]></content>
  </entry>
  
</feed>
